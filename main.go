package main

import (
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"flag"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type CDBEntry struct {
	Directory string
	Arguments []string
	Command   string
	File      string
}

type CDB []*CDBEntry

var (
	input  string
	output string
)

func init() {
	flag.StringVar(&input, "i", "compile_commands.json", "")
	flag.StringVar(&output, "o", "compile_commands.json", "")
	flag.Parse()
}

func loadCDB(file string) (CDB, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	var cdb CDB
	err = json.NewDecoder(f).Decode(&cdb)
	if err != nil {
		return nil, err
	}
	for _, entry := range cdb {
		// generated by cmake
		if len(entry.Arguments) == 0 && entry.Command != "" {
			entry.Arguments = strings.Fields(entry.Command)
		}
	}
	return cdb, nil
}

func main() {
	log.SetFlags(0)

	cdb, err := loadCDB(input)
	if err != nil {
		log.Fatalln(err)
	}
	log.Printf("Generating %s, ...\n", output)
	leading := strings.Repeat(" ", 2)
	var buf strings.Builder
	buf.WriteString("[\n")
	for i, entry := range cdb {
		var content string
		log.Printf("Processing %s, ...\n", entry.File)
		content, err = processEntry(entry)
		if err != nil {
			log.Fatalln(err)
		}
		log.Printf("Processing %s, done", entry.File)
		buf.WriteString(leading)
		content = strings.TrimRight(content, "\r\n")
		if i == len(cdb)-1 && content[len(content)-1] == ',' {
			buf.WriteString(content[:len(content)-1])
		} else {
			buf.WriteString(content)
		}
		buf.WriteString("\n")
	}
	buf.WriteString("]\n")
	outf, err := os.OpenFile(output, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatalln(err)
	}
	defer outf.Close()
	outf.WriteString(buf.String())
	log.Printf("Generating %s, done\n", output)
}

func processEntry(entry *CDBEntry) (string, error) {
	var args []string
	md5sum := md5.Sum([]byte(entry.File))
	name := hex.EncodeToString(md5sum[:])
	file := filepath.Join(os.TempDir(), name+".json")
	args = append(args, entry.Arguments[1:]...)
	args = append(args, "-MJ", file)
	cmd := exec.Command(entry.Arguments[0], args...)
	cmd.Dir = entry.Directory
	if err := cmd.Run(); err != nil {
		return "", err
	}
	data, err := os.ReadFile(file)
	if err != nil {
		return "", err
	}
	return string(data), nil
}
